{"ast":null,"code":"// src/Animated.ts\nimport { defineHidden } from \"@react-spring/shared\";\nvar $node = Symbol.for(\"Animated:node\");\n\nvar isAnimated = value => !!value && value[$node] === value;\n\nvar getAnimated = owner => owner && owner[$node];\n\nvar setAnimated = (owner, node) => defineHidden(owner, $node, node);\n\nvar getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\n\nvar Animated = class {\n  constructor() {\n    setAnimated(this, this);\n  }\n  /** Get every `AnimatedValue` used by this node. */\n\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}; // src/AnimatedValue.ts\n\nimport { is } from \"@react-spring/shared\";\nvar AnimatedValue = class extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.durationProgress = 0;\n\n    if (is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n  /** @internal */\n\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}; // src/AnimatedString.ts\n\nimport { is as is2, createInterpolator } from \"@react-spring/shared\";\nvar AnimatedString = class extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = createInterpolator({\n      output: [value, value]\n    });\n  }\n  /** @internal */\n\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    const value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (is2.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}; // src/AnimatedArray.ts\n\nimport { isAnimatedString } from \"@react-spring/shared\"; // src/AnimatedObject.ts\n\nimport { each, eachProp, getFluidValue, hasFluidValue } from \"@react-spring/shared\"; // src/context.ts\n\nvar TreeContext = {\n  dependencies: null\n}; // src/AnimatedObject.ts\n\nvar AnimatedObject = class extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset());\n    }\n  }\n  /** Create a payload set. */\n\n\n  _makePayload(source) {\n    if (source) {\n      const payload = /* @__PURE__ */new Set();\n      eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      each(payload, node => this.add(node));\n    }\n  }\n\n}; // src/AnimatedArray.ts\n\nvar AnimatedArray = class extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n  /** @internal */\n\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n};\n\nfunction makeAnimated(value) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n} // src/getAnimatedType.ts\n\n\nimport { is as is3, isAnimatedString as isAnimatedString2 } from \"@react-spring/shared\";\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is3.arr(value) ? AnimatedArray : isAnimatedString2(value) ? AnimatedString : AnimatedValue;\n} // src/createHost.ts\n\n\nimport { is as is5, eachProp as eachProp2 } from \"@react-spring/shared\"; // src/withAnimated.tsx\n\nimport * as React from \"react\";\nimport { forwardRef, useRef, useCallback, useEffect } from \"react\";\nimport { is as is4, each as each2, raf, useForceUpdate, useOnce, addFluidObserver, removeFluidObserver, useIsomorphicLayoutEffect } from \"@react-spring/shared\";\n\nvar withAnimated = (Component, host) => {\n  const hasInstance = // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is4.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef((givenProps, givenRef) => {\n    const instanceRef = useRef(null);\n    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks\n    useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = useRef();\n    useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer;\n      each2(deps, dep => addFluidObserver(dep, observer));\n      return () => {\n        if (observerRef.current) {\n          each2(observerRef.current.deps, dep => removeFluidObserver(dep, observerRef.current));\n          raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    useEffect(callback, []);\n    useOnce(() => () => {\n      const observer2 = observerRef.current;\n      each2(observer2.deps, dep => removeFluidObserver(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */React.createElement(Component, { ...usedProps,\n      ref\n    });\n  });\n};\n\nvar PropsObserver = class {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      raf.write(this.update);\n    }\n  }\n\n};\n\nfunction getAnimatedState(props, host) {\n  const dependencies = /* @__PURE__ */new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = { ...props,\n    style: host.createAnimatedStyle(props.style)\n  };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is4.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n} // src/createHost.ts\n\n\nvar cacheKey = Symbol.for(\"AnimatedComponent\");\n\nvar createHost = function (components) {\n  let {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n\n    if (is5.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  eachProp2(components, (Component, key) => {\n    if (is5.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nvar getDisplayName = arg => is5.str(arg) ? arg : arg && is5.str(arg.displayName) ? arg.displayName : is5.fun(arg) && arg.name || null;\n\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"mappings":"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","names":["defineHidden","$node","Symbol","for","isAnimated","value","getAnimated","owner","setAnimated","node","getPayload","Animated","constructor","payload","is","AnimatedValue","_value","done","durationProgress","num","lastPosition","create","getValue","setValue","step","Math","round","reset","elapsedTime","lastVelocity","v0","createInterpolator","AnimatedString","_string","_toString","output","str","goal","isAnimatedString","each","eachProp","getFluidValue","hasFluidValue","TreeContext","dependencies","AnimatedObject","source","animated","values","key","_makePayload","Set","_addToPayload","Array","from","add","AnimatedArray","map","length","i","some","Boolean","makeAnimated","nodeType","getAnimatedType","parentNode","arr","React","forwardRef","useRef","useCallback","useEffect","raf","useForceUpdate","useOnce","addFluidObserver","removeFluidObserver","useIsomorphicLayoutEffect","withAnimated","Component","host","hasInstance","fun","prototype","isReactComponent","givenProps","givenRef","instanceRef","ref","current","updateRef","props","deps","getAnimatedState","forceUpdate","callback","instance","didUpdate","applyAnimatedValues","observer","PropsObserver","observerRef","dep","cancel","update","usedProps","getComponentProps","createElement","eventObserved","event","type","write","style","createAnimatedStyle","cacheKey","createHost","components","hostConfig","displayName","getDisplayName","arg","name"],"ignoreList":[],"sources":["C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\Animated.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\AnimatedValue.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\AnimatedString.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\AnimatedArray.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\AnimatedObject.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\context.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\getAnimatedType.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\createHost.ts","C:\\Users\\ANDRIAM'Hajatiana\\Desktop\\portfolio\\portfolio-starter\\node_modules\\@react-spring\\animated\\src\\withAnimated.tsx"],"sourcesContent":["import { defineHidden } from '@react-spring/shared'\nimport { AnimatedValue } from './AnimatedValue'\n\nconst $node: any = Symbol.for('Animated:node')\n\nexport const isAnimated = <T = any>(value: any): value is Animated<T> =>\n  !!value && value[$node] === value\n\n/** Get the owner's `Animated` node. */\nexport const getAnimated = <T = any>(owner: any): Animated<T> | undefined =>\n  owner && owner[$node]\n\n/** Set the owner's `Animated` node. */\nexport const setAnimated = (owner: any, node: Animated) =>\n  defineHidden(owner, $node, node)\n\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\nexport const getPayload = (owner: any): AnimatedValue[] | undefined =>\n  owner && owner[$node] && owner[$node].getPayload()\n\nexport abstract class Animated<T = any> {\n  /** The cache of animated values */\n  protected payload?: Payload\n\n  constructor() {\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this)\n  }\n\n  /** Get the current value. Pass `true` for only animated values. */\n  abstract getValue(animated?: boolean): T\n\n  /** Set the current value. Returns `true` if the value changed. */\n  abstract setValue(value: T): boolean | void\n\n  /** Reset any animation state. */\n  abstract reset(goal?: T): void\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload(): Payload {\n    return this.payload || []\n  }\n}\n\nexport type Payload = readonly AnimatedValue[]\n","import { is } from '@react-spring/shared'\nimport { Animated, Payload } from './Animated'\n\n/** An animated number or a native attribute value */\nexport class AnimatedValue<T = any> extends Animated {\n  done = true\n  elapsedTime!: number\n  lastPosition!: number\n  lastVelocity?: number | null\n  v0?: number | null\n  durationProgress = 0\n\n  constructor(protected _value: T) {\n    super()\n    if (is.num(this._value)) {\n      this.lastPosition = this._value\n    }\n  }\n\n  /** @internal */\n  static create(value: any) {\n    return new AnimatedValue(value)\n  }\n\n  getPayload(): Payload {\n    return [this]\n  }\n\n  getValue() {\n    return this._value\n  }\n\n  setValue(value: T, step?: number) {\n    if (is.num(value)) {\n      this.lastPosition = value\n      if (step) {\n        value = (Math.round(value / step) * step) as any\n        if (this.done) {\n          this.lastPosition = value as any\n        }\n      }\n    }\n    if (this._value === value) {\n      return false\n    }\n    this._value = value\n    return true\n  }\n\n  reset() {\n    const { done } = this\n    this.done = false\n    if (is.num(this._value)) {\n      this.elapsedTime = 0\n      this.durationProgress = 0\n      this.lastPosition = this._value\n      if (done) this.lastVelocity = null\n      this.v0 = null\n    }\n  }\n}\n","import { AnimatedValue } from './AnimatedValue'\nimport { is, createInterpolator } from '@react-spring/shared'\n\ntype Value = string | number\n\nexport class AnimatedString extends AnimatedValue<Value> {\n  protected declare _value: number\n  protected _string: string | null = null\n  protected _toString: (input: number) => string\n\n  constructor(value: string) {\n    super(0)\n    this._toString = createInterpolator({\n      output: [value, value],\n    })\n  }\n\n  /** @internal */\n  static create(value: string) {\n    return new AnimatedString(value)\n  }\n\n  getValue() {\n    const value = this._string\n    return value == null ? (this._string = this._toString(this._value)) : value\n  }\n\n  setValue(value: Value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false\n      }\n      this._string = value\n      this._value = 1\n    } else if (super.setValue(value)) {\n      this._string = null\n    } else {\n      return false\n    }\n    return true\n  }\n\n  reset(goal?: string) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal],\n      })\n    }\n    this._value = 0\n    super.reset()\n  }\n}\n","import { isAnimatedString } from '@react-spring/shared'\nimport { AnimatedObject } from './AnimatedObject'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\n\ntype Value = number | string\ntype Source = AnimatedValue<Value>[]\n\n/** An array of animated nodes */\nexport class AnimatedArray<\n  T extends ReadonlyArray<Value> = Value[]\n> extends AnimatedObject {\n  protected declare source: Source\n  constructor(source: T) {\n    super(source)\n  }\n\n  /** @internal */\n  static create<T extends ReadonlyArray<Value>>(source: T) {\n    return new AnimatedArray(source)\n  }\n\n  getValue(): T {\n    return this.source.map(node => node.getValue()) as any\n  }\n\n  setValue(source: T) {\n    const payload = this.getPayload()\n    // Reuse the payload when lengths are equal.\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean)\n    }\n    // Remake the payload when length changes.\n    super.setValue(source.map(makeAnimated))\n    return true\n  }\n}\n\nfunction makeAnimated(value: any) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue\n  return nodeType.create(value)\n}\n","import { Lookup } from '@react-spring/types'\nimport {\n  each,\n  eachProp,\n  getFluidValue,\n  hasFluidValue,\n} from '@react-spring/shared'\nimport { Animated, isAnimated, getPayload } from './Animated'\nimport { AnimatedValue } from './AnimatedValue'\nimport { TreeContext } from './context'\n\n/** An object containing `Animated` nodes */\nexport class AnimatedObject extends Animated {\n  constructor(protected source: Lookup) {\n    super()\n    this.setValue(source)\n  }\n\n  getValue(animated?: boolean) {\n    const values: Lookup = {}\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated)\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source)\n      } else if (!animated) {\n        values[key] = source\n      }\n    })\n    return values\n  }\n\n  /** Replace the raw object data */\n  setValue(source: Lookup) {\n    this.source = source\n    this.payload = this._makePayload(source)\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset())\n    }\n  }\n\n  /** Create a payload set. */\n  protected _makePayload(source: Lookup) {\n    if (source) {\n      const payload = new Set<AnimatedValue>()\n      eachProp(source, this._addToPayload, payload)\n      return Array.from(payload)\n    }\n  }\n\n  /** Add to a payload set. */\n  protected _addToPayload(this: Set<AnimatedValue>, source: any) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source)\n    }\n    const payload = getPayload(source)\n    if (payload) {\n      each(payload, node => this.add(node))\n    }\n  }\n}\n","import { FluidValue } from '@react-spring/shared'\n\nexport type TreeContext = {\n  /**\n   * Any animated values found when updating the payload of an `AnimatedObject`\n   * are also added to this `Set` to be observed by an animated component.\n   */\n  dependencies: Set<FluidValue> | null\n}\n\nexport const TreeContext: TreeContext = { dependencies: null }\n","import { is, isAnimatedString } from '@react-spring/shared'\nimport { AnimatedType } from './types'\nimport { AnimatedArray } from './AnimatedArray'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\nimport { getAnimated } from './Animated'\n\n/** Return the `Animated` node constructor for a given value */\nexport function getAnimatedType(value: any): AnimatedType {\n  const parentNode = getAnimated(value)\n  return parentNode\n    ? (parentNode.constructor as any)\n    : is.arr(value)\n    ? AnimatedArray\n    : isAnimatedString(value)\n    ? AnimatedString\n    : AnimatedValue\n}\n","import { Lookup } from '@react-spring/types'\nimport { is, eachProp } from '@react-spring/shared'\nimport { AnimatableComponent, withAnimated } from './withAnimated'\nimport { Animated } from './Animated'\nimport { AnimatedObject } from './AnimatedObject'\n\nexport interface HostConfig {\n  /** Provide custom logic for native updates */\n  applyAnimatedValues: (node: any, props: Lookup) => boolean | void\n  /** Wrap the `style` prop with an animated node */\n  createAnimatedStyle: (style: Lookup) => Animated\n  /** Intercept props before they're passed to an animated component */\n  getComponentProps: (props: Lookup) => typeof props\n}\n\n// A stub type that gets replaced by @react-spring/web and others.\ntype WithAnimated = {\n  (Component: AnimatableComponent): any\n  [key: string]: any\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent')\n\nexport const createHost = (\n  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },\n  {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props,\n  }: Partial<HostConfig> = {}\n) => {\n  const hostConfig: HostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps,\n  }\n\n  const animated: WithAnimated = (Component: any) => {\n    const displayName = getDisplayName(Component) || 'Anonymous'\n\n    if (is.str(Component)) {\n      Component =\n        animated[Component] ||\n        (animated[Component] = withAnimated(Component, hostConfig))\n    } else {\n      Component =\n        Component[cacheKey] ||\n        (Component[cacheKey] = withAnimated(Component, hostConfig))\n    }\n\n    Component.displayName = `Animated(${displayName})`\n    return Component\n  }\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component)!\n    }\n    animated[key] = animated(Component)\n  })\n\n  return {\n    animated,\n  }\n}\n\nconst getDisplayName = (arg: AnimatableComponent) =>\n  is.str(arg)\n    ? arg\n    : arg && is.str(arg.displayName)\n    ? arg.displayName\n    : (is.fun(arg) && arg.name) || null\n","import * as React from 'react'\nimport { forwardRef, useRef, Ref, useCallback, useEffect } from 'react'\nimport {\n  is,\n  each,\n  raf,\n  useForceUpdate,\n  useOnce,\n  FluidEvent,\n  FluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n  useIsomorphicLayoutEffect,\n} from '@react-spring/shared'\nimport { ElementType } from '@react-spring/types'\n\nimport { AnimatedObject } from './AnimatedObject'\nimport { TreeContext } from './context'\nimport { HostConfig } from './createHost'\n\nexport type AnimatableComponent = string | Exclude<ElementType, string>\n\nexport const withAnimated = (Component: any, host: HostConfig) => {\n  const hasInstance: boolean =\n    // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !is.fun(Component) ||\n    (Component.prototype && Component.prototype.isReactComponent)\n\n  return forwardRef((givenProps: any, givenRef: Ref<any>) => {\n    const instanceRef = useRef<any>(null)\n\n    // The `hasInstance` value is constant, so we can safely avoid\n    // the `useCallback` invocation when `hasInstance` is false.\n    const ref =\n      hasInstance &&\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useCallback(\n        (value: any) => {\n          instanceRef.current = updateRef(givenRef, value)\n        },\n        [givenRef]\n      )\n\n    const [props, deps] = getAnimatedState(givenProps, host)\n\n    const forceUpdate = useForceUpdate()\n\n    const callback = () => {\n      const instance = instanceRef.current\n      if (hasInstance && !instance) {\n        // Either this component was unmounted before changes could be\n        // applied, or the wrapped component forgot to forward its ref.\n        return\n      }\n\n      const didUpdate = instance\n        ? host.applyAnimatedValues(instance, props.getValue(true))\n        : false\n\n      // Re-render the component when native updates fail.\n      if (didUpdate === false) {\n        forceUpdate()\n      }\n    }\n\n    const observer = new PropsObserver(callback, deps)\n\n    const observerRef = useRef<PropsObserver>()\n    useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer\n\n      // Observe the latest dependencies.\n      each(deps, dep => addFluidObserver(dep, observer))\n\n      return () => {\n        // Stop observing previous dependencies.\n        if (observerRef.current) {\n          each(observerRef.current.deps, dep =>\n            removeFluidObserver(dep, observerRef.current!)\n          )\n          raf.cancel(observerRef.current.update)\n        }\n      }\n    })\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(callback, [])\n    // Stop observing on unmount.\n    useOnce(() => () => {\n      const observer = observerRef.current!\n      each(observer.deps, dep => removeFluidObserver(dep, observer))\n    })\n\n    const usedProps = host.getComponentProps(props.getValue())\n    return <Component {...usedProps} ref={ref} />\n  })\n}\n\nclass PropsObserver {\n  constructor(readonly update: () => void, readonly deps: Set<FluidValue>) {}\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      raf.write(this.update)\n    }\n  }\n}\n\ntype AnimatedState = [props: AnimatedObject, dependencies: Set<FluidValue>]\n\nfunction getAnimatedState(props: any, host: HostConfig): AnimatedState {\n  const dependencies = new Set<FluidValue>()\n  TreeContext.dependencies = dependencies\n\n  // Search the style for dependencies.\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style),\n    }\n\n  // Search the props for dependencies.\n  props = new AnimatedObject(props)\n\n  TreeContext.dependencies = null\n  return [props, dependencies]\n}\n\nfunction updateRef<T>(ref: Ref<T>, value: T) {\n  if (ref) {\n    if (is.fun(ref)) ref(value)\n    else (ref as any).current = value\n  }\n  return value\n}\n"]},"metadata":{},"sourceType":"module"}